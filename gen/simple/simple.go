// Code generated by esmaq, DO NOT EDIT.
package simple

import (
	"context"
	"errors"
	decimal "github.com/shopspring/decimal"
	esmaq "github.com/stevenferrer/esmaq"
)

type State esmaq.StateType

func (s State) String() string {
	return string(s)
}

const (
	StateA State = "a"
	StateB State = "b"
	StateC State = "c"
)

type Event esmaq.EventType

func (e Event) String() string {
	return string(e)
}

const (
	EventAToB Event = "a_to_b"
	EventAToA Event = "a_to_a"
	EventBToC Event = "b_to_c"
	EventBToA Event = "b_to_a"
)

type ctxKey int

const (
	fromKey ctxKey = iota
	toKey
)

type Simple struct {
	core      *esmaq.Core
	callbacks *Callbacks
}

type Callbacks struct {
	AToB func(ctx context.Context, ii int, ii32 int32, ii64 int64) (oi int, oi32 int32, oi64 int64, err error)
	AToA func(ctx context.Context, iu uint, iu32 uint32, iu64 uint64) (of32 float32, of64 float32, err error)
	BToC func(ctx context.Context, mis string) (mos string, err error)
	BToA func(ctx context.Context, sp1 decimal.Decimal) (sp2 string, err error)
}

type Actions struct {
	A esmaq.Actions
	B esmaq.Actions
	C esmaq.Actions
}

func (sm *Simple) AToB(ctx context.Context, ii int, ii32 int32, ii64 int64) (oi int, oi32 int32, oi64 int64, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return 0, 0, 0, errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return 0, 0, 0, err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventAToB))
	if err != nil {
		return 0, 0, 0, err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateB)

	if sm.callbacks != nil && sm.callbacks.AToB != nil {
		oi, oi32, oi64, err = sm.callbacks.AToB(ctx, ii, ii32, ii64)
		if err != nil {
			return 0, 0, 0, err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return 0, 0, 0, err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return 0, 0, 0, err
		}
	}

	return oi, oi32, oi64, nil
}

func (sm *Simple) AToA(ctx context.Context, iu uint, iu32 uint32, iu64 uint64) (of32 float32, of64 float32, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return 0, 0, errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return 0, 0, err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventAToA))
	if err != nil {
		return 0, 0, err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateA)

	if sm.callbacks != nil && sm.callbacks.AToA != nil {
		of32, of64, err = sm.callbacks.AToA(ctx, iu, iu32, iu64)
		if err != nil {
			return 0, 0, err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return 0, 0, err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return 0, 0, err
		}
	}

	return of32, of64, nil
}

func (sm *Simple) BToC(ctx context.Context, mis string) (mos string, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return "", errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return "", err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventBToC))
	if err != nil {
		return "", err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateC)

	if sm.callbacks != nil && sm.callbacks.BToC != nil {
		mos, err = sm.callbacks.BToC(ctx, mis)
		if err != nil {
			return "", err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return "", err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return "", err
		}
	}

	return mos, nil
}

func (sm *Simple) BToA(ctx context.Context, sp1 decimal.Decimal) (sp2 string, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return "", errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return "", err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventBToA))
	if err != nil {
		return "", err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateA)

	if sm.callbacks != nil && sm.callbacks.BToA != nil {
		sp2, err = sm.callbacks.BToA(ctx, sp1)
		if err != nil {
			return "", err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return "", err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return "", err
		}
	}

	return sp2, nil
}

func CtxWtFrom(ctx context.Context, from State) context.Context {
	return context.WithValue(ctx, fromKey, from)
}

func ctxWtTo(ctx context.Context, to State) context.Context {
	return context.WithValue(ctx, toKey, to)
}

func fromCtx(ctx context.Context) (State, bool) {
	from, ok := ctx.Value(fromKey).(State)
	return from, ok
}

func ToCtx(ctx context.Context) (State, bool) {
	to, ok := ctx.Value(toKey).(State)
	return to, ok
}

func NewSimple(actions *Actions, callbacks *Callbacks) *Simple {
	stateConfigs := []esmaq.StateConfig{
		{
			From:    castst(StateA),
			Actions: actions.A,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: castet(EventAToB),
					To:    castst(StateB),
				},
				{
					Event: castet(EventAToA),
					To:    castst(StateA),
				},
			},
		},
		{
			From:    castst(StateB),
			Actions: actions.B,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: castet(EventBToC),
					To:    castst(StateC),
				},
				{
					Event: castet(EventBToA),
					To:    castst(StateA),
				},
			},
		},
		{
			From:        castst(StateC),
			Actions:     actions.C,
			Transitions: []esmaq.TransitionConfig{},
		},
	}

	simple := &Simple{
		core:      esmaq.NewCore(stateConfigs),
		callbacks: callbacks,
	}

	return simple
}

func castst(s State) esmaq.StateType {
	return esmaq.StateType(s)
}

func castet(e Event) esmaq.EventType {
	return esmaq.EventType(e)
}
