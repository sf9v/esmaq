// Code generated by esmaq, DO NOT EDIT.
package simple

import (
	"context"
	"errors"
	decimal "github.com/shopspring/decimal"
	esmaq "github.com/stevenferrer/esmaq"
)

// State is the state type
type State esmaq.StateType

// String implements Stringer for State
func (s State) String() string {
	return string(s)
}

// List of state types
const (
	StateA State = "a"
	StateB State = "b"
	StateC State = "c"
)

// Event is the event type
type Event esmaq.EventType

// String implements Stringer for Event
func (e Event) String() string {
	return string(e)
}

// List of event types
const (
	EventAToB Event = "a_to_b"
	EventAToA Event = "a_to_a"
	EventBToC Event = "b_to_c"
	EventBToA Event = "b_to_a"
)

// ctxKey is a context key
type ctxKey int

// List of context keys
const (
	fromKey ctxKey = iota
	toKey
)

// Simple is a state machine
type Simple struct {
	core      *esmaq.Core
	callbacks *Callbacks
}

// Callbacks defines the state machine callbacks
type Callbacks struct {
	AToB func(ctx context.Context, ii int, ii32 int32, ii64 int64) (oi int, oi32 int32, oi64 int64, err error)
	AToA func(ctx context.Context, iu uint, iu32 uint32, iu64 uint64) (of32 float32, of64 float32, err error)
	BToC func(ctx context.Context, mis string) (mos string, err error)
	BToA func(ctx context.Context, sp1 decimal.Decimal) (sp2 string, err error)
}

// Actions defines the state machine actions
type Actions struct {
	A esmaq.Actions
	B esmaq.Actions
	C esmaq.Actions
}

// AToB is a transition method for EventAToB
func (sm *Simple) AToB(ctx context.Context, ii int, ii32 int32, ii64 int64) (oi int, oi32 int32, oi64 int64, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return 0, 0, 0, errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return 0, 0, 0, err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventAToB))
	if err != nil {
		return 0, 0, 0, err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateB)

	if sm.callbacks != nil && sm.callbacks.AToB != nil {
		oi, oi32, oi64, err = sm.callbacks.AToB(ctx, ii, ii32, ii64)
		if err != nil {
			return 0, 0, 0, err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return 0, 0, 0, err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return 0, 0, 0, err
		}
	}

	return oi, oi32, oi64, nil
}

// AToA is a transition method for EventAToA
func (sm *Simple) AToA(ctx context.Context, iu uint, iu32 uint32, iu64 uint64) (of32 float32, of64 float32, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return 0, 0, errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return 0, 0, err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventAToA))
	if err != nil {
		return 0, 0, err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateA)

	if sm.callbacks != nil && sm.callbacks.AToA != nil {
		of32, of64, err = sm.callbacks.AToA(ctx, iu, iu32, iu64)
		if err != nil {
			return 0, 0, err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return 0, 0, err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return 0, 0, err
		}
	}

	return of32, of64, nil
}

// BToC is a transition method for EventBToC
func (sm *Simple) BToC(ctx context.Context, mis string) (mos string, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return "", errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return "", err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventBToC))
	if err != nil {
		return "", err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateC)

	if sm.callbacks != nil && sm.callbacks.BToC != nil {
		mos, err = sm.callbacks.BToC(ctx, mis)
		if err != nil {
			return "", err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return "", err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return "", err
		}
	}

	return mos, nil
}

// BToA is a transition method for EventBToA
func (sm *Simple) BToA(ctx context.Context, sp1 decimal.Decimal) (sp2 string, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return "", errors.New("\"from\" is not set in context")
	}

	fromst, err := sm.core.GetState(castst(from))
	if err != nil {
		return "", err
	}

	tost, err := sm.core.Transition(castst(from), castet(EventBToA))
	if err != nil {
		return "", err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateA)

	if sm.callbacks != nil && sm.callbacks.BToA != nil {
		sp2, err = sm.callbacks.BToA(ctx, sp1)
		if err != nil {
			return "", err
		}
	}

	if fromst.Actions.OnExit != nil {
		err = fromst.Actions.OnExit(ctx)
		if err != nil {
			return "", err
		}
	}

	if tost.Actions.OnEnter != nil {
		err = tost.Actions.OnEnter(ctx)
		if err != nil {
			return "", err
		}
	}

	return sp2, nil
}

// CtxWtFrom injects `from` state to context
func CtxWtFrom(ctx context.Context, from State) context.Context {
	return context.WithValue(ctx, fromKey, from)
}

// ctxWtTo injects 'to' state to context
func ctxWtTo(ctx context.Context, to State) context.Context {
	return context.WithValue(ctx, toKey, to)
}

// fromCtx retrieves 'from' state from context
func fromCtx(ctx context.Context) (State, bool) {
	from, ok := ctx.Value(fromKey).(State)
	return from, ok
}

// ToCtx retrieves 'to' state from context
func ToCtx(ctx context.Context) (State, bool) {
	to, ok := ctx.Value(toKey).(State)
	return to, ok
}

// NewSimple is a factory for state machine Simple
func NewSimple(callbacks *Callbacks, actions *Actions) *Simple {
	return &Simple{
		callbacks: callbacks,
		core: esmaq.NewCore([]esmaq.StateConfig{
			{
				From:    castst(StateA),
				Actions: actions.A,
				Transitions: []esmaq.TransitionConfig{
					{
						Event: castet(EventAToB),
						To:    castst(StateB),
					},
					{
						Event: castet(EventAToA),
						To:    castst(StateA),
					},
				},
			},
			{
				From:    castst(StateB),
				Actions: actions.B,
				Transitions: []esmaq.TransitionConfig{
					{
						Event: castet(EventBToC),
						To:    castst(StateC),
					},
					{
						Event: castet(EventBToA),
						To:    castst(StateA),
					},
				},
			},
			{
				From:        castst(StateC),
				Actions:     actions.C,
				Transitions: []esmaq.TransitionConfig{},
			},
		}),
	}
}

// castst casts State to esmaq.StateType
func castst(s State) esmaq.StateType {
	return esmaq.StateType(s)
}

// castet casts Event to esmaq.EventType
func castet(e Event) esmaq.EventType {
	return esmaq.EventType(e)
}
