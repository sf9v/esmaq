package gen

import (
	"io"
	"reflect"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"

	"github.com/stevenferrer/esmaq"
)

const pkgPath = "github.com/stevenferrer/esmaq"

// Schema is the state machine schema
type Schema struct {
	// Name is the state machine name
	Name,
	// Pkg is package name
	Pkg string
	// States is the states config
	States []State
}

type State struct {
	From        esmaq.StateType
	Transitions []Transition
}

type Transition struct {
	To       esmaq.StateType
	Event    esmaq.EventType
	Callback Callback
}

// Callback is a callback function signature
type Callback struct {
	Ins  []Arg
	Outs []Arg
}

type Arg struct {
	ID string
	T  interface{}
}

// Gen generates the state machine
func Gen(schema Schema, out io.Writer) error {
	// default name
	name := "StateMachine"
	if len(schema.Name) > 0 {
		name = schema.Name
	}

	// camelize name
	name = toCamel(name)

	//default package name
	pkg := "main"
	if len(schema.Pkg) > 0 {
		pkg = schema.Pkg
	}

	f := jen.NewFile(pkg)
	f.PackageComment("Code generated by esmaq, DO NOT EDIT.")

	rcvr := "sm"
	rcvrType := "*" + name

	states := []State{}
	states = append(states, schema.States...)

	// helper method for checking if
	// state is already in collection
	isIn := func(s esmaq.StateType) bool {
		for _, state := range states {
			if s == state.From {
				return true
			}
		}
		return false
	}

	for _, stateCfg := range schema.States {
		for _, trsnCfg := range stateCfg.Transitions {
			if isIn(trsnCfg.To) {
				continue
			}

			states = append(states, State{From: trsnCfg.To})
		}
	}

	// state types
	f.Type().Id("State").Qual(pkgPath, "StateType")
	f.Const().DefsFunc(func(g *jen.Group) {
		for _, state := range states {
			s := string(state.From)
			g.Id(stName(state.From)).Id("State").Op("=").Lit(s)
		}
	}).Line()

	// event types
	f.Type().Id("Event").Qual(pkgPath, "EventType")
	f.Const().DefsFunc(func(g *jen.Group) {
		for _, state := range states {
			for _, trsn := range state.Transitions {
				e := string(trsn.Event)
				g.Id(etName(trsn.Event)).Id("Event").Op("=").Lit(e)
			}
		}
	})

	f.Type().Id("ctxKey").
		Int()
	f.Const().DefsFunc(func(g *jen.Group) {
		g.Id("fromKey").Id("ctxKey").Op("=").Id("iota")
		g.Id("toKey")
	})

	// callback function arguments
	cbFnArgs := []jen.Code{}
	// transition methods
	methods := []jen.Code{}
	for _, state := range states {
		for _, trsn := range state.Transitions {
			fnName := toCamel(string(trsn.Event))

			// input args
			ins := []jen.Code{jen.Id("ctx").Qual("context", "Context")}
			// input arg identifiers
			inIDs := []jen.Code{jen.Id("ctx")}
			for _, in := range trsn.Callback.Ins {
				ins = append(ins, getArg(in.ID, reflect.TypeOf(in.T)))
				inIDs = append(inIDs, jen.Id(in.ID))
			}

			// output args
			outs := []jen.Code{}
			// output arg identifiers
			outIDs := []jen.Code{}
			// return args when error happened
			errRets := []jen.Code{}

			for _, out := range trsn.Callback.Outs {
				t := reflect.TypeOf(out.T)
				outs = append(outs, getArg(out.ID, t))
				outIDs = append(outIDs, jen.Id(out.ID))
				errRets = append(errRets, getZeroVal(t))
			}

			// return args when no error happened
			okRets := append(cloneC(outIDs), jen.Nil())

			// add err in as last arg
			outs = append(outs, jen.Id("err").Error())
			outIDs = append(outIDs, jen.Id("err"))

			cbName := fnName
			cbFnArgs = append(cbFnArgs, jen.Id(cbName).Func().
				Params(ins...).Params(outs...))

			method := jen.Func().Params(jen.Id(rcvr).Id(rcvrType)).
				Id(fnName).Params(ins...).Params(outs...).
				BlockFunc(func(g *jen.Group) {
					g.List(jen.Id("from"), jen.Id("ok")).
						Op(":=").Id("fromCtx").Call(jen.Id("ctx"))
					g.If(jen.Op("!").Id("ok")).
						BlockFunc(func(g *jen.Group) {
							g.Return(append(cloneC(errRets), jen.Qual("errors", "New").
								Call(jen.Lit(`"from" is not set in context`)))...)
						}).
						Line()

					g.List(jen.Id("fromst"), jen.Id("err")).Op(":=").Id(rcvr).
						Dot("core").Dot("GetState").
						Call(jen.Id("castst").Call(jen.Id("from")))
					g.If(jen.Err().Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							g.Return(append(cloneC(errRets), jen.Id("err"))...)
						}).Line()

					g.List(jen.Id("tost"), jen.Id("err")).
						Op(":=").Id(rcvr).Dot("core").Dot("Transition").
						Call(jen.Id("castst").Call(jen.Id("from")),
							jen.Id("castet").Call(jen.Id(etName(trsn.Event))))
					g.If(jen.Err().Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							g.Return(append(cloneC(errRets), jen.Id("err"))...)
						}).Line()

					g.Comment(`inject "to" in context`)
					g.Id("ctx").Op("=").Id("ctxWtTo").
						Call(jen.Id("ctx"), jen.Id(stName(trsn.To))).Line()

					g.If(jen.Id(rcvr).Dot("callbacks").Op("!=").Nil()).Op("&&").
						Id(rcvr).Dot("callbacks").Dot(cbName).Op("!=").Nil().
						BlockFunc(func(g *jen.Group) {
							g.List(outIDs...).Op("=").Id(rcvr).Dot("callbacks").
								Dot(cbName).Call(inIDs...)
							g.If(jen.Err().Op("!=").Nil()).
								BlockFunc(func(g *jen.Group) {
									g.Return(append(cloneC(errRets), jen.Id("err"))...)
								}).Line()
						}).
						Line()

					g.If(jen.Id("fromst").
						Dot("Actions").
						Dot("OnExit").
						Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							g.Err().Op("=").Id("fromst").Dot("Actions").
								Dot("OnExit").Call(jen.Id("ctx"))
							g.If(jen.Err().Op("!=").Nil()).
								BlockFunc(func(g *jen.Group) {
									g.Return(append(cloneC(errRets), jen.Id("err"))...)
								})
						}).
						Line()

					g.If(jen.Id("tost").Dot("Actions").Dot("OnEnter").Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							g.Err().Op("=").Id("tost").Dot("Actions").Dot("OnEnter").
								Call(jen.Id("ctx"))
							g.If(jen.Err().Op("!=").Nil()).
								BlockFunc(func(g *jen.Group) {
									g.Return(append(cloneC(errRets), jen.Id("err"))...)
								})
						}).
						Line()

					g.Return(okRets...)
				})

			methods = append(methods, method)
		}
	}

	// type definition
	f.Type().Id(name).Struct(
		jen.Id("core").Op("*").Qual(pkgPath, "Core"),
		jen.Id("callbacks").Op("*").Id("Callbacks"),
	).Line()

	// callback and actions type definition
	f.Type().Id("Callbacks").Struct(cbFnArgs...).Line()
	f.Type().Id("Actions").StructFunc(func(g *jen.Group) {
		for _, state := range states {
			g.Id(toCamel(string(state.From))).Qual(pkgPath, "Actions")
		}
	})

	// transition methods
	for _, m := range methods {
		f.Add(m).Line()
	}

	// context helpers
	f.Func().Id("CtxWtFrom").
		Params(jen.Id("ctx").Qual("context", "Context"),
			jen.Id("from").Id("State"),
		).
		Params(jen.Qual("context", "Context")).
		BlockFunc(func(g *jen.Group) {
			g.Return(jen.Qual("context", "WithValue").
				Call(jen.Id("ctx"), jen.Id("fromKey"), jen.Id("from")))
		}).Line()

	f.Func().Id("ctxWtTo").
		Params(jen.Id("ctx").Qual("context", "Context"),
			jen.Id("to").Id("State"),
		).
		Params(jen.Qual("context", "Context")).
		BlockFunc(func(g *jen.Group) {
			g.Return(jen.Qual("context", "WithValue").
				Call(jen.Id("ctx"), jen.Id("toKey"), jen.Id("to")))
		}).Line()

	f.Func().Id("fromCtx").
		Params(jen.Id("ctx").Qual("context", "Context")).
		Params(jen.Id("State"), jen.Bool()).
		BlockFunc(func(g *jen.Group) {
			g.List(jen.Id("from"), jen.Id("ok")).
				Op(":=").
				Id("ctx").
				Dot("Value").
				Call(jen.Id("fromKey")).
				Assert(jen.Id("State"))

			g.Return(jen.Id("from"), jen.Id("ok"))
		}).Line()

	f.Func().Id("ToCtx").
		Params(jen.Id("ctx").Qual("context", "Context")).
		Params(jen.Id("State"), jen.Bool()).
		BlockFunc(func(g *jen.Group) {
			g.List(jen.Id("to"), jen.Id("ok")).
				Op(":=").
				Id("ctx").
				Dot("Value").
				Call(jen.Id("toKey")).
				Assert(jen.Id("State"))

			g.Return(jen.Id("to"), jen.Id("ok"))
		}).Line()

	// factory
	f.Func().Id("New"+toCamel(name)).
		Params(
			jen.Id("actions").Op("*").Id("Actions"),
			jen.Id("callbacks").Op("*").Id("Callbacks"),
		).
		Params(jen.Id("*" + name)).
		BlockFunc(func(g *jen.Group) {
			g.Id("stateConfigs").Op(":=").Op("[]").
				Qual(pkgPath, "StateConfig").
				BlockFunc(func(g *jen.Group) {
					for _, state := range states {
						g.BlockFunc(func(g *jen.Group) {
							g.Id("From").Op(":").Id("castst").
								Call(jen.Id(stName(state.From))).Op(",")
							g.Id("Actions").Op(":").Id("actions").
								Dot(toCamel(string(state.From))).Op(",")
							g.Id("Transitions").Op(":").Op("[]").
								Qual(pkgPath, "TransitionConfig").
								BlockFunc(func(g *jen.Group) {
									for _, trsn := range state.Transitions {
										g.BlockFunc(func(g *jen.Group) {
											g.Id("Event").Op(":").Id("castet").
												Call(jen.Id(etName(trsn.Event))).Op(",")
											g.Id("To").Op(":").Id("castst").
												Call(jen.Id(stName(trsn.To))).Op(",")
										}).Op(",")
									}
								}).Op(",")
						}).Op(",")
					}

				}).Line()

			g.Id(toLowCamel(name)).
				Op(":=").Op("&").Id(name).
				BlockFunc(func(g *jen.Group) {
					g.Id("core").Op(":").
						Qual(pkgPath, "NewCore").
						Params(jen.Id("stateConfigs")).Op(",")
					g.Id("callbacks").Op(":").Id("callbacks").Op(",")
				}).Line()
			g.Return().Id(toLowCamel(name))
		}).Line()

	f.Func().Id("castst").Params(jen.Id("s").Id("State")).
		Params(jen.Qual(pkgPath, "StateType")).
		Block(jen.Return(jen.Qual(pkgPath, "StateType").Call(jen.Id("s")))).
		Line()
	f.Func().Id("castet").Params(jen.Id("e").Id("Event")).
		Params(jen.Qual(pkgPath, "EventType")).
		Block(jen.Return(jen.Qual(pkgPath, "EventType").Call(jen.Id("e"))))

	return f.Render(out)
}

func getArg(id string, t reflect.Type) jen.Code {
	c := jen.Id(id)

	// FIXME: add support for reference types (t.String())
	// built-in types
	if t.Name() != "" {
		switch t.String() {
		case "int":
			return c.Int()
		case "int32":
			return c.Int32()
		case "int64":
			return c.Int64()
		case "uint":
			return c.Uint()
		case "uint32":
			return c.Uint32()
		case "uint64":
			return c.Uint64()
		case "float32":
			return c.Float32()
		case "float64":
			return c.Float32()
		case "string":
			return c.String()
		case "error":
			return c.Error()
		}
	}

	return c.Qual(t.PkgPath(), t.Name())
}

func getZeroVal(t reflect.Type) jen.Code {

	// FIXME: add support for other types
	// built-in types
	if t.Name() != "" {
		switch t.Name() {
		case "int":
			return jen.Lit(0)
		case "int32":
			return jen.Lit(0)
		case "int64":
			return jen.Lit(0)
		case "uint":
			return jen.Lit(0)
		case "uint32":
			return jen.Lit(0)
		case "uint64":
			return jen.Lit(0)
		case "float32":
			return jen.Lit(0)
		case "float64":
			return jen.Lit(0)
		case "string":
			return jen.Lit("")
		}
	}
	return jen.Nil()
}

func toCamel(s string) string {
	return strcase.ToCamel(s)
}

func toLowCamel(s string) string {
	return strcase.ToLowerCamel(s)
}

func cloneC(c1 []jen.Code) []jen.Code {
	c2 := []jen.Code{}
	return append(c2, c1...)
}

func stName(s esmaq.StateType) string {
	return toCamel("state_" + string(s))
}

func etName(e esmaq.EventType) string {
	return toCamel("event_" + string(e))
}
