package gen

import (
	"fmt"
	"io"
	"reflect"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"

	"github.com/stevenferrer/esmaq"
)

const pkgPath = "github.com/stevenferrer/esmaq"

// Schema is the state machine schema
type Schema struct {
	// Name is the state machine name
	Name,
	// Pkg is package name
	Pkg string
	// States is the states config
	States []State
}

type State struct {
	From        esmaq.StateType
	Transitions []Transition
}

type Transition struct {
	To       esmaq.StateType
	Event    esmaq.EventType
	Callback Callback
}

// Callback is a callback function signature
type Callback struct {
	Ins  Ins
	Outs Outs
}

// Ins are input parameters
type Ins map[string]interface{}

// Outs are output parameters
type Outs map[string]interface{}

// Gen generates the state machine
func Gen(schema Schema, out io.Writer) error {
	// default name
	name := "StateMachine"
	if len(schema.Name) > 0 {
		name = schema.Name
	}

	// camelize name
	name = toCam(name)

	//default package name
	pkg := "main"
	if len(schema.Pkg) > 0 {
		pkg = schema.Pkg
	}

	f := jen.NewFile(pkg)
	f.PackageComment("Code generated by esmaq, DO NOT EDIT.")

	rcvr := "sm"
	rcvrType := "*" + name

	// get all possible states
	states := map[esmaq.StateType]bool{schema.States[0].From: true}
	for _, state := range schema.States {
		for _, trsn := range state.Transitions {
			_, ok := states[trsn.To]
			if !ok {
				states[trsn.To] = true
			}
		}
	}

	f.Type().Id("State").Op("=").Qual(pkgPath, "StateType")
	f.Const().DefsFunc(func(g *jen.Group) {
		for state := range states {
			s := string(state)
			sName := toCam(fmt.Sprintf("state_%s", s))
			g.Id(sName).Id("State").Op("=").Lit(s)
		}
	})

	f.Line()
	f.Type().Id("Event").Op("=").Qual(pkgPath, "EventType")
	f.Const().DefsFunc(func(g *jen.Group) {
		for _, state := range schema.States {
			for _, trsn := range state.Transitions {
				e := string(trsn.Event)
				eName := toCam(fmt.Sprintf("event_%s", trsn.Event))
				g.Id(eName).Id("Event").Op("=").Lit(e)
			}
		}
	})

	f.Type().Id("ctxKey").
		Int()
	f.Const().DefsFunc(func(g *jen.Group) {
		g.Id("fromKey").Id("ctxKey").Op("=").Id("iota")
		g.Id("toKey")
	})

	cbcArgs := []jen.Code{}
	methods := []jen.Code{}

	for _, state := range schema.States {
		for _, trsn := range state.Transitions {
			fnName := toCam(string(trsn.Event))

			// input args
			ins := []jen.Code{
				jen.Id("ctx").Qual("context", "Context"),
			}
			// input arg identifiers
			inIDs := []jen.Code{jen.Id("ctx")}
			for id, v := range trsn.Callback.Ins {
				ins = append(ins, getArg(id, reflect.TypeOf(v)))
				inIDs = append(inIDs, jen.Id(id))
			}

			// output args
			outs := []jen.Code{}
			// output arg identifiers
			outIDs := []jen.Code{}
			// return args when error happened
			errRets := []jen.Code{}

			for id, v := range trsn.Callback.Outs {
				t := reflect.TypeOf(v)
				outs = append(outs, getArg(id, t))
				outIDs = append(outIDs, jen.Id(id))
				errRets = append(errRets, getZeroVal(t))
			}

			// return args when no error happened
			okRets := append(outIDs, jen.Nil())
			outs = append(outs, jen.Id("err").Error())
			outIDs = append(outIDs, jen.Id("err"))

			cbName := fnName
			cbcArgs = append(cbcArgs, jen.Id(cbName).Func().
				Params(ins...).Params(outs...))

			method := jen.Func().Params(jen.Id(rcvr).Id(rcvrType)).
				Id(fnName).Params(ins...).Params(outs...).
				BlockFunc(func(g *jen.Group) {
					jen.Id("next").Qual(pkgPath, "State").
						Op("=").Lit(string(trsn.To))

					// get "from" in context
					g.List(jen.Id("from"), jen.Id("ok")).Op(":=").
						Id("fromCtx").Call(jen.Id("ctx"))

					g.If(jen.Op("!").Id("ok")).
						BlockFunc(func(g *jen.Group) {
							rets := append(errRets, jen.Qual("errors", "New").
								Call(jen.Lit(`"from" state not set in context`)))
							g.Return(rets...)
						}).Line()

					g.List(jen.Id("fromState"), jen.Id("err")).Op(":=").Id(rcvr).
						Dot("core").Dot("GetState").Call(jen.Id("from"))
					g.If(jen.Err().Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							rets := append(errRets, jen.Id("err"))
							g.Return(rets...)
						}).Line()

					g.List(jen.Id("toState"), jen.Id("err")).
						Op(":=").Id(rcvr).
						Dot("core").
						Dot("Transition").
						Call(jen.Id(toCam("event_"+string(trsn.Event))), jen.Id("from"))
					g.If(jen.Err().Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							rets := append(errRets, jen.Id("err"))
							g.Return(rets...)
						}).Line()

					toState := toCam("state_" + string(trsn.To))
					g.Comment(`inject "to" in context`)
					g.Id("ctx").Op("=").Id("ctxWtTo").
						Call(jen.Id("ctx"), jen.Id(toState)).Line()

					g.If(jen.Id("fromState").
						Dot("Actions").
						Dot("OnExit").
						Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							g.Err().Op("=").Id("fromState").Dot("Actions").
								Dot("OnExit").Call(jen.Id("ctx"))
							g.If(jen.Err().Op("!=").Nil()).
								BlockFunc(func(g *jen.Group) {
									rets := append(errRets, jen.Id("err"))
									g.Return(rets...)
								})
						}).
						Line()

					g.If(jen.Id(rcvr).Dot("callbacks").Op("!=").Nil()).Op("&&").
						Id(rcvr).Dot("callbacks").Dot(cbName).Op("!=").Nil().
						BlockFunc(func(g *jen.Group) {
							g.List(outIDs...).Op("=").Id(rcvr).Dot("callbacks").
								Dot(cbName).Call(inIDs...)
							g.If(jen.Err().Op("!=").Nil()).
								BlockFunc(func(g *jen.Group) {
									rets := append(errRets, jen.Id("err"))
									g.Return(rets...)
								}).Line()
						}).
						Line()

					g.If(jen.Id("toState").Dot("Actions").Dot("OnEnter").Op("!=").Nil()).
						BlockFunc(func(g *jen.Group) {
							g.Err().Op("=").Id("toState").Dot("Actions").Dot("OnEnter").
								Call(jen.Id("ctx"))
							g.If(jen.Err().Op("!=").Nil()).
								BlockFunc(func(g *jen.Group) {
									rets := append(errRets, jen.Id("err"))
									g.Return(rets...)
								})
						}).
						Line()

					g.Return(okRets...)
				})

			methods = append(methods, method)
		}
	}

	// state machine type def
	f.Type().Id(name).Struct(
		jen.Id("core").Op("*").Qual(pkgPath, "Core"),
		jen.Id("callbacks").Op("*").Id("Callbacks"),
	).Line()

	// callbacks type def
	f.Type().Id("Callbacks").Struct(cbcArgs...).Line()
	f.Type().Id("Actions").StructFunc(func(g *jen.Group) {
		for state := range states {
			g.Id(toCam(string(state))).Qual(pkgPath, "Actions")
		}
	})

	for _, m := range methods {
		f.Add(m).Line()
	}

	f.Func().Id("CtxWtFrom").
		Params(jen.Id("ctx").Qual("context", "Context"),
			jen.Id("from").Id("State"),
		).
		Params(jen.Qual("context", "Context")).
		BlockFunc(func(g *jen.Group) {
			g.Return(jen.Qual("context", "WithValue").
				Call(jen.Id("ctx"), jen.Id("fromKey"), jen.Id("from")))
		}).Line()

	f.Func().Id("ctxWtTo").
		Params(jen.Id("ctx").Qual("context", "Context"),
			jen.Id("to").Id("State"),
		).
		Params(jen.Qual("context", "Context")).
		BlockFunc(func(g *jen.Group) {
			g.Return(jen.Qual("context", "WithValue").
				Call(jen.Id("ctx"), jen.Id("toKey"), jen.Id("to")))
		}).Line()

	f.Func().Id("fromCtx").
		Params(jen.Id("ctx").Qual("context", "Context")).
		Params(jen.Id("State"), jen.Bool()).
		BlockFunc(func(g *jen.Group) {
			g.List(jen.Id("from"), jen.Id("ok")).
				Op(":=").
				Id("ctx").
				Dot("Value").
				Call(jen.Id("fromKey")).
				Assert(jen.Id("State"))

			g.Return(jen.Id("from"), jen.Id("ok"))
		}).Line()

	f.Func().Id("ToCtx").
		Params(jen.Id("ctx").Qual("context", "Context")).
		Params(jen.Id("State"), jen.Bool()).
		BlockFunc(func(g *jen.Group) {
			g.List(jen.Id("to"), jen.Id("ok")).
				Op(":=").
				Id("ctx").
				Dot("Value").
				Call(jen.Id("toKey")).
				Assert(jen.Id("State"))

			g.Return(jen.Id("to"), jen.Id("ok"))
		}).Line()

	f.Func().Id("New"+toCam(name)).
		Params(
			jen.Id("actions").Op("*").Id("Actions"),
			jen.Id("callbacks").Op("*").Id("Callbacks"),
		).
		Params(jen.Id("*" + name)).
		BlockFunc(func(g *jen.Group) {
			g.Id("stateConfigs").Op(":=").Op("[]").
				Qual(pkgPath, "StateConfig").
				BlockFunc(func(g *jen.Group) {
					for _, state := range schema.States {
						g.BlockFunc(func(g *jen.Group) {
							g.Id("From").Op(":").Id(toCam("state_" + string(state.From))).Op(",")
							g.Id("Actions").Op(":").Id("actions").Dot(toCam(string(state.From))).Op(",")
							g.Id("Transitions").Op(":").Op("[]").
								Qual(pkgPath, "TransitionConfig").
								BlockFunc(func(g *jen.Group) {
									for _, trsn := range state.Transitions {
										g.BlockFunc(func(g *jen.Group) {
											g.Id("Event").Op(":").Id(toCam("event_" + string(trsn.Event))).Op(",")
											g.Id("To").Op(":").Id(toCam("state_" + string(trsn.To))).Op(",")
										}).Op(",")
									}
								}).Op(",")
						}).Op(",")
					}
				}).Line()

			g.Id(toLowCam(name)).
				Op(":=").Op("&").Id(name).
				BlockFunc(func(g *jen.Group) {
					g.Id("core").Op(":").
						Qual(pkgPath, "NewCore").
						Params(jen.Id("stateConfigs")).Op(",")
					g.Id("callbacks").Op(":").Id("callbacks").Op(",")
				}).Line()
			g.Return().Id(toLowCam(name))
		})

	return f.Render(out)
}

func getArg(id string, t reflect.Type) jen.Code {
	c := jen.Id(id)

	// built-in types
	if t.Name() != "" {
		switch t.Name() {
		case "int":
			return c.Int()
		case "int32":
			return c.Int32()
		case "int64":
			return c.Int64()
		case "uint":
			return c.Uint()
		case "uint32":
			return c.Uint32()
		case "uint64":
			return c.Uint64()
		case "float32":
			return c.Float32()
		case "float64":
			return c.Float32()
		case "string":
			return c.String()
		case "error":
			return c.Error()
		}
	}

	return c.Qual(t.PkgPath(), t.Name())
}

func getZeroVal(t reflect.Type) jen.Code {
	// built-in types
	if t.Name() != "" {
		switch t.Name() {
		case "int":
			return jen.Lit(0)
		case "int32":
			return jen.Lit(0)
		case "int64":
			return jen.Lit(0)
		case "uint":
			return jen.Lit(0)
		case "uint32":
			return jen.Lit(0)
		case "uint64":
			return jen.Lit(0)
		case "float32":
			return jen.Lit(0)
		case "float64":
			return jen.Lit(0)
		case "string":
			return jen.Lit("")
		}
	}

	return jen.Nil()
}

func toCam(s string) string {
	return strcase.ToCamel(s)
}

func toLowCam(s string) string {
	return strcase.ToLowerCamel(s)
}
