// Code generated by esmaq, DO NOT EDIT.
package cart

import (
	"context"
	"errors"
	esmaq "github.com/stevenferrer/esmaq"
)

type State = esmaq.StateType

const (
	StateSubmitted  State = "submitted"
	StateCancelled  State = "cancelled"
	StateShopping   State = "shopping"
	StateFinalizing State = "finalizing"
	StatePaid       State = "paid"
)

type Event = esmaq.EventType

const (
	EventCheckout Event = "checkout"
	EventPay      Event = "pay"
	EventModify   Event = "modify"
	EventSubmit   Event = "submit"
	EventCancel   Event = "cancel"
)

type ctxKey int

const (
	fromKey ctxKey = iota
	toKey
)

type Cart struct {
	core      *esmaq.Core
	callbacks *Callbacks
}

type Callbacks struct {
	Checkout func(ctx context.Context, cartID int64) (err error)
	Pay      func(ctx context.Context, cartID int64, paymentId int64) (err error)
	Modify   func(ctx context.Context) (err error)
	Submit   func(ctx context.Context, cartID int64) (orderId int64, err error)
	Cancel   func(ctx context.Context, cartID int64) (cancelID int64, err error)
}

type Actions struct {
	Finalizing esmaq.Actions
	Paid       esmaq.Actions
	Submitted  esmaq.Actions
	Cancelled  esmaq.Actions
	Shopping   esmaq.Actions
}

func (sm *Cart) Checkout(ctx context.Context, cartID int64) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventCheckout, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateFinalizing)

	if sm.callbacks != nil && sm.callbacks.Checkout != nil {
		err = sm.callbacks.Checkout(ctx, cartID)
		if err != nil {
			return err
		}

	}

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (sm *Cart) Pay(ctx context.Context, cartID int64, paymentId int64) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventPay, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StatePaid)

	if sm.callbacks != nil && sm.callbacks.Pay != nil {
		err = sm.callbacks.Pay(ctx, cartID, paymentId)
		if err != nil {
			return err
		}

	}

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (sm *Cart) Modify(ctx context.Context) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventModify, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateShopping)

	if sm.callbacks != nil && sm.callbacks.Modify != nil {
		err = sm.callbacks.Modify(ctx)
		if err != nil {
			return err
		}

	}

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (sm *Cart) Submit(ctx context.Context, cartID int64) (orderId int64, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return 0, errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return 0, err
	}

	toState, err := sm.core.Transition(EventSubmit, from)
	if err != nil {
		return 0, err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateSubmitted)

	if sm.callbacks != nil && sm.callbacks.Submit != nil {
		orderId, err = sm.callbacks.Submit(ctx, cartID)
		if err != nil {
			return 0, err
		}

	}

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return 0, err
		}
	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return 0, err
		}
	}

	return orderId, nil
}

func (sm *Cart) Cancel(ctx context.Context, cartID int64) (cancelID int64, err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return 0, errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return 0, err
	}

	toState, err := sm.core.Transition(EventCancel, from)
	if err != nil {
		return 0, err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateCancelled)

	if sm.callbacks != nil && sm.callbacks.Cancel != nil {
		cancelID, err = sm.callbacks.Cancel(ctx, cartID)
		if err != nil {
			return 0, err
		}

	}

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return 0, err
		}
	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return 0, err
		}
	}

	return cancelID, nil
}

func CtxWtFrom(ctx context.Context, from State) context.Context {
	return context.WithValue(ctx, fromKey, from)
}

func ctxWtTo(ctx context.Context, to State) context.Context {
	return context.WithValue(ctx, toKey, to)
}

func fromCtx(ctx context.Context) (State, bool) {
	from, ok := ctx.Value(fromKey).(State)
	return from, ok
}

func ToCtx(ctx context.Context) (State, bool) {
	to, ok := ctx.Value(toKey).(State)
	return to, ok
}

func NewCart(actions *Actions, callbacks *Callbacks) *Cart {
	stateConfigs := []esmaq.StateConfig{
		{
			From:    StateShopping,
			Actions: actions.Shopping,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: EventCheckout,
					To:    StateFinalizing,
				},
			},
		},
		{
			From:    StateFinalizing,
			Actions: actions.Finalizing,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: EventPay,
					To:    StatePaid,
				},
				{
					Event: EventModify,
					To:    StateShopping,
				},
			},
		},
		{
			From:    StatePaid,
			Actions: actions.Paid,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: EventSubmit,
					To:    StateSubmitted,
				},
				{
					Event: EventCancel,
					To:    StateCancelled,
				},
			},
		},
	}

	cart := &Cart{
		core:      esmaq.NewCore(stateConfigs),
		callbacks: callbacks,
	}

	return cart
}
