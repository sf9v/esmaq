// Code generated by esmaq, DO NOT EDIT.
package matter

import (
	"context"
	"errors"
	esmaq "github.com/stevenferrer/esmaq"
)

type State = esmaq.StateType

const (
	StateLiquid State = "liquid"
	StateGas    State = "gas"
	StateSolid  State = "solid"
)

type Event = esmaq.EventType

const (
	EventMelt     Event = "melt"
	EventFreeze   Event = "freeze"
	EventVaporize Event = "vaporize"
	EventCondense Event = "condense"
)

type ctxKey int

const (
	fromKey ctxKey = iota
	toKey
)

type Matter struct {
	core      *esmaq.Core
	callbacks *Callbacks
}

type Callbacks struct {
	Melt     func(ctx context.Context) (err error)
	Freeze   func(ctx context.Context) (err error)
	Vaporize func(ctx context.Context) (err error)
	Condense func(ctx context.Context) (err error)
}

type Actions struct {
	Solid  esmaq.Actions
	Liquid esmaq.Actions
	Gas    esmaq.Actions
}

func (sm *Matter) Melt(ctx context.Context) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventMelt, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateLiquid)

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if sm.callbacks != nil && sm.callbacks.Melt != nil {
		err = sm.callbacks.Melt(ctx)
		if err != nil {
			return err
		}

	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (sm *Matter) Freeze(ctx context.Context) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventFreeze, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateSolid)

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if sm.callbacks != nil && sm.callbacks.Freeze != nil {
		err = sm.callbacks.Freeze(ctx)
		if err != nil {
			return err
		}

	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (sm *Matter) Vaporize(ctx context.Context) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventVaporize, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateGas)

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if sm.callbacks != nil && sm.callbacks.Vaporize != nil {
		err = sm.callbacks.Vaporize(ctx)
		if err != nil {
			return err
		}

	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (sm *Matter) Condense(ctx context.Context) (err error) {
	from, ok := fromCtx(ctx)
	if !ok {
		return errors.New("\"from\" state not set in context")
	}

	fromState, err := sm.core.GetState(from)
	if err != nil {
		return err
	}

	toState, err := sm.core.Transition(EventCondense, from)
	if err != nil {
		return err
	}

	// inject "to" in context
	ctx = ctxWtTo(ctx, StateLiquid)

	if fromState.Actions.OnExit != nil {
		err = fromState.Actions.OnExit(ctx)
		if err != nil {
			return err
		}
	}

	if sm.callbacks != nil && sm.callbacks.Condense != nil {
		err = sm.callbacks.Condense(ctx)
		if err != nil {
			return err
		}

	}

	if toState.Actions.OnEnter != nil {
		err = toState.Actions.OnEnter(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func CtxWtFrom(ctx context.Context, from State) context.Context {
	return context.WithValue(ctx, fromKey, from)
}

func ctxWtTo(ctx context.Context, to State) context.Context {
	return context.WithValue(ctx, toKey, to)
}

func fromCtx(ctx context.Context) (State, bool) {
	from, ok := ctx.Value(fromKey).(State)
	return from, ok
}

func ToCtx(ctx context.Context) (State, bool) {
	to, ok := ctx.Value(toKey).(State)
	return to, ok
}

func NewMatter(actions *Actions, callbacks *Callbacks) *Matter {
	stateConfigs := []esmaq.StateConfig{
		{
			From:    StateSolid,
			Actions: actions.Solid,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: EventMelt,
					To:    StateLiquid,
				},
			},
		},
		{
			From:    StateLiquid,
			Actions: actions.Liquid,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: EventFreeze,
					To:    StateSolid,
				},
				{
					Event: EventVaporize,
					To:    StateGas,
				},
			},
		},
		{
			From:    StateGas,
			Actions: actions.Gas,
			Transitions: []esmaq.TransitionConfig{
				{
					Event: EventCondense,
					To:    StateLiquid,
				},
			},
		},
	}

	matter := &Matter{
		core:      esmaq.NewCore(stateConfigs),
		callbacks: callbacks,
	}

	return matter
}
